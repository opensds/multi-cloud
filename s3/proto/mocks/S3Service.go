// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import client "github.com/micro/go-micro/client"
import context "context"
import mock "github.com/stretchr/testify/mock"
import s3 "github.com/opensds/multi-cloud/s3/proto"

// S3Service is an autogenerated mock type for the S3Service type
type S3Service struct {
	mock.Mock
}

// AddUploadRecord provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) AddUploadRecord(ctx context.Context, in *s3.MultipartUploadRecord, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.MultipartUploadRecord, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.MultipartUploadRecord, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CountObjects provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) CountObjects(ctx context.Context, in *s3.ListObjectsRequest, opts ...client.CallOption) (*s3.CountObjectsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.CountObjectsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsRequest, ...client.CallOption) *s3.CountObjectsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CountObjectsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.ListObjectsRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateBucket provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) CreateBucket(ctx context.Context, in *s3.Bucket, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.Bucket, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.Bucket, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateObject provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) CreateObject(ctx context.Context, in *s3.Object, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.Object, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.Object, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBucket provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) DeleteBucket(ctx context.Context, in *s3.Bucket, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.Bucket, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.Bucket, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteBucketLifecycle provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) DeleteBucketLifecycle(ctx context.Context, in *s3.DeleteLifecycleInput, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.DeleteLifecycleInput, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.DeleteLifecycleInput, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteObject provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) DeleteObject(ctx context.Context, in *s3.DeleteObjectInput, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectInput, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectInput, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteUploadRecord provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) DeleteUploadRecord(ctx context.Context, in *s3.MultipartUploadRecord, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.MultipartUploadRecord, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.MultipartUploadRecord, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBackendTypeByTier provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) GetBackendTypeByTier(ctx context.Context, in *s3.GetBackendTypeByTierRequest, opts ...client.CallOption) (*s3.GetBackendTypeByTierResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.GetBackendTypeByTierResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.GetBackendTypeByTierRequest, ...client.CallOption) *s3.GetBackendTypeByTierResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBackendTypeByTierResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.GetBackendTypeByTierRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucket provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) GetBucket(ctx context.Context, in *s3.Bucket, opts ...client.CallOption) (*s3.Bucket, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.Bucket
	if rf, ok := ret.Get(0).(func(context.Context, *s3.Bucket, ...client.CallOption) *s3.Bucket); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.Bucket)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.Bucket, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetObject provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) GetObject(ctx context.Context, in *s3.GetObjectInput, opts ...client.CallOption) (*s3.Object, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.Object
	if rf, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...client.CallOption) *s3.Object); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.Object)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.GetObjectInput, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStorageClasses provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) GetStorageClasses(ctx context.Context, in *s3.BaseRequest, opts ...client.CallOption) (*s3.GetStorageClassesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.GetStorageClassesResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.BaseRequest, ...client.CallOption) *s3.GetStorageClassesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetStorageClassesResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.BaseRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTierMap provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) GetTierMap(ctx context.Context, in *s3.BaseRequest, opts ...client.CallOption) (*s3.GetTierMapResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.GetTierMapResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.BaseRequest, ...client.CallOption) *s3.GetTierMapResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetTierMapResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.BaseRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuckets provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) ListBuckets(ctx context.Context, in *s3.BaseRequest, opts ...client.CallOption) (*s3.ListBucketsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.ListBucketsResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.BaseRequest, ...client.CallOption) *s3.ListBucketsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListBucketsResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.BaseRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListObjects provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) ListObjects(ctx context.Context, in *s3.ListObjectsRequest, opts ...client.CallOption) (*s3.ListObjectResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.ListObjectResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsRequest, ...client.CallOption) *s3.ListObjectResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListObjectResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.ListObjectsRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUploadRecord provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) ListUploadRecord(ctx context.Context, in *s3.ListMultipartUploadRequest, opts ...client.CallOption) (*s3.ListMultipartUploadResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.ListMultipartUploadResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.ListMultipartUploadRequest, ...client.CallOption) *s3.ListMultipartUploadResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListMultipartUploadResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.ListMultipartUploadRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateBucket provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) UpdateBucket(ctx context.Context, in *s3.Bucket, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.Bucket, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.Bucket, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateObjMeta provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) UpdateObjMeta(ctx context.Context, in *s3.UpdateObjMetaRequest, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.UpdateObjMetaRequest, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.UpdateObjMetaRequest, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateObject provides a mock function with given fields: ctx, in, opts
func (_m *S3Service) UpdateObject(ctx context.Context, in *s3.Object, opts ...client.CallOption) (*s3.BaseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *s3.BaseResponse
	if rf, ok := ret.Get(0).(func(context.Context, *s3.Object, ...client.CallOption) *s3.BaseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.BaseResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *s3.Object, ...client.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
